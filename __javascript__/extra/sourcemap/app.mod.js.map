{
	"version": 3,
	"file": "/Users/sp/code/ghita/__javascript__/app.mod.js",
	"sources": [
		"/Users/sp/code/ghita/app.py"
	],
	"sourcesContent": [
		"from typing import Any, Dict, List, Optional, Callable\n\nimport app_config\nimport constants\nimport utils\n\n\n__pragma__('skip')\n# Hack to ignore static check errors on objects included at runtime.\n__pragma__ = Tonal = window = console = Set = Vue = __new__ = object()  # type: Any\n__pragma__('noskip')\n\nclass Note:\n  \"\"\"Represents a note.\n\n  Attributes:\n      note: str, string representation\n      interval_to_tonic: str, interval to tonic, if this note is in a scale\n      selected: bool, this note is selected\n  \"\"\"\n  def __init__(self,\n      note: str,\n      interval_to_tonic: str = None,\n      selected: bool = False) -> None:\n    self.note = self.normalize(note)\n    self.interval_to_tonic = interval_to_tonic\n    self.selected = selected\n    self.update()\n\n  def select(self, select: bool = True) -> Note:\n    \"\"\"Marks or unmarks this note as selected.\"\"\"\n    self.selected = select\n    return self\n\n  def interval(self, interval: str = None) -> Note:\n    \"\"\"Sets interval relative to tonic.\"\"\"\n    self.interval_to_tonic = interval\n    return self\n\n  def update(self) -> None:\n    \"\"\"Updates all derived attributes, such as those used in Vue.\"\"\"\n    pass\n\n  @classmethod\n  def normalize(self, note: str) -> str:\n    \"\"\"Simplifies and normalizes flats to sharps.\"\"\"\n    note = Tonal.Note.simplify(note)\n    if note.endswith('b'):\n      note = Tonal.Note.enharmonic(note)\n    return note\n\n\nclass NotesCollection:\n  \"\"\"Collection of notes.\n\n  Attributes:\n      type: str, 'chord' or 'scale'\n      notes: List[Note], list of notes\n      all_notes_sorted: List[Note], 12 chromatic notes (some selected),\n          starting from A\n      all_notes: List[Note], similar to all_notes_sorted, but starting from root\n  \"\"\"\n  def __init__(self):\n    pass\n\n  def _getNotes(self) -> List[str]:\n    \"\"\"Gets notes as strings in this particular collection.\"\"\"\n    raise NotImplementedError()\n\n  def updateNotes(self):\n    tonal_notes_str = self._getNotes()\n\n    notes_str = []\n    for note_str in tonal_notes_str:\n      notes_str.append(Note.normalize(note_str))\n\n    self.notes = []\n    self.all_notes_sorted = []\n    for index, note_str in enumerate(constants.NOTES):\n      selected = notes_str.includes(note_str)\n      interval = Tonal.Distance.interval(self.root.note, note_str)\n      if selected:\n        self.notes.append(Note(note_str, interval, selected))\n      self.all_notes_sorted.append(Note(note_str, interval, selected))\n\n      if note_str == self.root.note:\n        root_index = index\n\n    self.all_notes = utils.rotate(self.all_notes_sorted, root_index)\n\n\nclass Chord(NotesCollection):\n  \"\"\"Represents a chord.\n\n  Attributes:\n      root: Note, root note\n      chord: str, chord type\n\n    inherited from NotesCollection:\n      type\n      notes\n      all_notes\n      all_notes_sorted\n  \"\"\"\n  TYPE = 'chord'\n\n  def __init__(self,\n      config: app_config.AppConfig,\n      root: Note = Note('C', '1P', True),\n      chord: str = 'M') -> None:\n    self.type = self.TYPE\n    self.config = config\n    self.root = root\n    self.chord = chord\n    self.update()\n\n  def setRoot(self, root: str) -> Chord:\n    self.root = Note(root, '1P', True)\n    self.update()\n    return self\n\n  def setChord(self, chord: str) -> Chord:\n    self.chord = chord\n    self.update()\n    return self\n\n  def setRootAndChord(self, root, chord):\n    self.root = Note(root, '1P', True)\n    self.chord = chord\n    self.update()\n\n  def _getNotes(self) -> List[str]:\n    return Tonal.Chord.notes('{0} {1}'.format(self.root.note, self.chord))\n\n  def contains(self, note_to_check: str) -> Optional[str]:\n    \"\"\"Checks if the chord contains the note.\n\n    Returns:\n        interval if True, None otherwise.\n    \"\"\"\n    for note in self.notes:\n      if note_to_check == note.note:\n        return note.interval_to_tonic\n    return None\n\n  def update(self):\n    \"\"\"Updates all derived attributes, such as those used in Vue.\"\"\"\n    console.log('updating chord ' + self.root.note + ' ' + self.chord)\n    self.updateNotes()\n\n\nclass Scale(NotesCollection):\n  \"\"\"Represents a scale.\n\n  Attributes:\n      root: Note, root note\n      scale: str, scale type\n\n      chords: [str], possible chords with current root, for suggestion in\n          selector UI\n      all_chords: Dict[str, List[str]], map of notes in scale to possible\n          chords, used to look at chord progressions\n      all_chords_transposed: List[List[str]], transposed all_chords, used for UI\n\n    inherited from NotesCollection:\n      type\n      notes\n      all_notes\n      all_notes_sorted\n  \"\"\"\n  TYPE = 'scale'\n\n  def __init__(self,\n      config: app_config.AppConfig,\n      root: str = 'C',\n      scale: str = 'ionian') -> None:\n    self.type = self.TYPE\n    self.config = config\n    self.root = Note(root, '1P', True)\n    self.scale = scale\n    self.update()\n\n  def setRoot(self, note: str) -> Scale:\n    self.root = Note(note, '1P', True)\n    self.update()\n    return self\n\n  def setScale(self, scale: str) -> Scale:\n    self.scale = scale\n    self.update()\n    return self\n\n  def setRootAndScale(self, root: str, scale: str) -> None:\n    self.root = Note(root, '1P', True)\n    self.scale = scale\n    self.update()\n\n  def contains(self, note_to_check: str) -> Optional[str]:\n    \"\"\"Checks if the scale contains the note.\n\n    Returns:\n        interval if True, None otherwise.\n    \"\"\"\n    for note in self.notes:\n      if note_to_check == note.note:\n        return note.interval_to_tonic\n    return None\n\n  def _getNotes(self) -> List[str]:\n    return Tonal.Scale.notes('{0} {1}'.format(self.root.note, self.scale))\n\n  def update(self):\n    \"\"\"Updates all derived attributes.\"\"\"\n    console.log('updating scale ' + self.root.note + ' ' + self.scale)\n    self.updateNotes()\n\n    scaleNameStr = '{0} {1}'.format(self.root.note, self.scale)\n    self.chords = Tonal.Scale.chords(scaleNameStr)\n\n    self.all_chords = {}\n    modes = Tonal.Scale.modeNames(scaleNameStr)\n    # TODO: For blues, we only get 2 alternate modes.\n    # TODO: It's possible to use Tonal.Detect.chords, but result is pretty fuzzy\n    for mode in modes:\n      rootNote = mode[0]\n      chordsForNote = Tonal.Scale.chords(\n          '{0} {1}'.format(rootNote, mode[1]))\n      if self.config.simple_chords:\n        chordsForNote = chordsForNote.filter(\n            lambda c: constants.CHORDS_SET.has(c))\n      self.all_chords[rootNote] = chordsForNote\n\n    # Construct transposed array for available chords for each note in scale.\n    arrays = []\n    for note in self.all_notes:\n      if note.note in self.all_chords:\n        arrays.append(self.all_chords[note.note])\n      else:\n        # Empty list of chords for notes that are not in scale.\n        arrays.append([])\n    self.all_chords_transposed = utils.transpose(arrays)\n\n\nclass Fret:\n  \"\"\"Represents a fret.\n\n  Attributes:\n    note: Note, note\n    marker: bool, if this has a fret marker\n    fret_number: int, fret number\n  \"\"\"\n  def __init__(self,\n      note: Note,\n      marker: bool,\n      fret_number: int) -> None:\n    self.note = note\n    self.marker = marker\n    self.fret_number = fret_number\n\n\nclass Fretboard:\n  \"\"\"Represents a fretboard.\n\n  Attributes:\n    instrument_config: Dict[str, Any], instrument config in constants module\n    frets: Dict[int, Dict[int, Fret]], map [string][fret] to Note, representing\n        all frets\n    shown_frets: List[Fret], frets currently shown\n  \"\"\"\n  def __init__(self, config: app_config.AppConfig) -> None:\n    self.config = config\n    self.update()\n\n  def update(self):\n    self.shown_frets = []  # type: List[Fret]\n    self.frets = {}  # type: Dict[int, Dict[int, Fret]]\n\n    if self.config.instrument == 'guitar':\n      self.instrument_config = constants.GUITAR\n    elif self.config.instrument == 'ukulele':\n      self.instrument_config = constants.UKULELE\n\n    for string, open_note in enumerate(self.instrument_config['OPEN_NOTES']):\n      self.frets[string] = {}\n      for fret in range(self.instrument_config['FRETS']):\n        note = Note.normalize(Tonal.Distance.transpose(\n            open_note, Tonal.Interval.fromSemitones(fret)))\n        self.frets[string][fret] = Fret(\n            Note(note), self.instrument_config['FRET_MARKERS'].has(fret), fret)\n\n  def showNotes(self, notes_collection: NotesCollection):\n    \"\"\"Shows notes in this collection on the fretboard.\"\"\"\n    self.reset()\n\n    notes_str = []\n    for note in notes_collection.notes:\n      notes_str.append(note.note)\n\n    for string in range(len(self.instrument_config['OPEN_NOTES'])):\n      for fret in range(self.instrument_config['FRETS']):\n        # indexOf does not work for a List[Note] and Note\n        index = notes_str.indexOf(self.frets[string][fret].note.note)\n        if index != -1:\n          self.frets[string][fret].note.select().interval(\n              notes_collection.notes[index].interval_to_tonic)\n          self.shown_frets.append(self.frets[string][fret])\n\n  def reset(self):\n    for fret in self.shown_frets:\n      fret.note.select(False).interval(None)\n    self.shown_frets = []\n\n\nclass QuickList:\n  \"\"\"Quick access list of scales, chords, etc.\n\n  Attributes:\n    visible: bool\n    collections: List[List[str]]\n    len: int, number of items in the list\n  \"\"\"\n  def __init__(self) -> None:\n    # TODO: Use some sort of ordered set instead.\n    # TODO: Make Chord and Scale immutable, then we can simply store the\n    # instances. Currently they're mutable so we have to store the strings.\n    self.collections = []  # type: List[List[str]]\n    self.update()\n\n  def add(self, collection: List[str]) -> None:\n    self.collections.append(collection)\n    self.update()\n\n  def remove(self, index: int) -> None:\n    \"\"\"Removes indexed collection.\"\"\"\n    self.collections.splice(index, 1)\n    self.update()\n\n  def clearAll(self) -> None:\n    self.collections = []\n    self.update()\n\n  def update(self):\n    \"\"\"Updates derived attributes.\"\"\"\n    self.len = len(self.collections)\n    self.visible = self.len > 0\n\n  def displayStr(self, collection: List[str]) -> str:\n    \"\"\"Converts to a string for display in UI.\"\"\"\n    return '{0} {1} {2}'.format(collection[0], collection[1], collection[2])\n\n\nclass App(object):\n  def __init__(self) -> None:\n    self.config = app_config.AppConfig()\n    self.scale = Scale(self.config)\n    self.chord = Chord(self.config)\n    self.fretboard = Fretboard(self.config)\n    self.fretboard.showNotes(self.scale)\n    self.quicklist = QuickList()\n\n  def start(self) -> None:\n    console.log('python start()')\n    self.initVue()\n\n  def onChangeOptionSimpleChords(self):\n    console.log('Simple chords: ' + self.config.simple_chords)\n    self.scale.update()\n\n  def onChangeOptionsInstrument(self):\n    console.log('Selected instrument: ' + self.config.instrument)\n    self.fretboard.update()\n    self.fretboard.showNotes(self.scale)\n\n  # TODO: prefer not to expose this function through 'methods'. Move this into\n  # the quicklist object or something.\n  def onQuicklistSelect(self, index: int) -> None:\n    col = self.quicklist.collections[index]\n    if col[0] == 'scale':\n      self.scale.setRootAndScale(col[1], col[2])\n      self.fretboard.showNotes(self.scale)\n    elif col[0] == 'chord':\n      self.chord.setRootAndChord(col[1], col[2])\n      self.fretboard.showNotes(self.chord)\n\n\n  def initVue(self) -> None:\n    # (#15) Workaround.\n    if not window.vue_loaded:\n      window.vue_loaded = True\n      window.app = __new__(Vue({\n        'el': '#app',\n        'data': {\n          'scale': self.scale,\n          'chord': self.chord,\n          'fretboard': self.fretboard,\n          'config': self.config,\n          'quicklist': self.quicklist,\n          'Tonal': Tonal,\n          'VUE_CONSTANTS': constants.VUE_CONSTANTS,\n        },\n        # Watch for v-model's.\n        'watch': {\n          'config.simple_chords': self.onChangeOptionSimpleChords,\n          'config.instrument': self.onChangeOptionsInstrument,\n        },\n        'methods': {\n          # TODO: move these into quicklist or something\n          'onQuicklistSelect': self.onQuicklistSelect,\n        },\n      }))\n\nwindow.addEventListener('load', lambda: App().start())\n"
	],
	"mappings": "AAAA;AA2ZA;AAAA;AAAA;AA3ZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAQA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AAAA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAUA;AACA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AAaA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAMA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAGA;AAAA;AAmBA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAMA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAQA;AAIA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AASA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAQA;AAIA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AAEA;AAAA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}